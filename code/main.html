<!DOCTYPE html>
<html>
<head>
   <title>IWE</title>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <link href="js/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">
   <script src="js/lib/jquery-2.2.3.min.js"></script>
   <script src="js/lib/bootstrap/js/bootstrap.min.js"></script>
	<script src="js/lib/d3.min.js" charset="utf-8"></script>
   <style>
   .border-wrap{
	height:500px
   }
   #svg-wrap{
	height:500px;
	min-height: 20px;
	background-color: #fcfcfc;
	border: 1px solid #e3e3e3;
	border-radius: 4px;
	-webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.05);
	box-shadow: inset 0 1px 1px rgba(0,0,0,.05);
   }
	.axis path,
	.axis line{
		fill: none;
		stroke: black;
		shape-rendering: crispEdges;
	}
	 
	.axis text {
		font-family: sans-serif;
		font-size: 11px;
	}
   </style>
</head>
<body>
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
   <div class="navbar-header">
      <a class="navbar-brand" style="font-weight:bold;">Issue Workflow Explorer</a>
   </div>
   <div>
      <ul class="nav navbar-nav">
	    <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">
               Database <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
               <li><a href="#">Gnome</a></li>
               <li><a href="#">Mozilla</a></li>
            </ul>
        </li>
        <li><a href="#">Help</a></li>
        <li><a href="#">About</a></li>
      </ul>
   </div>
</nav>
<div class="container" style='margin-top:50px;width:100%'>
<div class="row">
<div class="col-md-8" style="padding:8px"><div class="border-wrap">
<div class="row">
<div class="col-md-3">
<div class="panel panel-default" style="margin-top:5px;">
   <div class="panel-heading" style="background-color: #EFFEEF;">
      <h3 class="panel-title">
         SELECTORS
      </h3>
   </div>
   <div class="panel-body" style="height:500px">
      面板内容
   </div>
</div>
</div>
<div class="col-md-9" style='padding-left:0px'>
<div style="text-align:center"><h3 style="margin-top:5px">Workflow</h3></div>
<div id="svg-wrap"></div>
</div>
</div>
</div></div>
<div class="col-md-3" style="padding:8px"><div class="border-wrap">ss</div></div>
</div>
</div>
<script>
// an example of transition data
d = {'NEW ASSIGNED NEW RESOLVED VERIFIED': {'num': 868,
  'ts': [960114565, 961989692, 971563564, 980116902, 985813821]},
 'NEW ASSIGNED RESOLVED': {'num': 1277,
  'ts': [962415032, 971897691, 1011844691]},
 'NEW ASSIGNED RESOLVED VERIFIED': {'num': 5608,
  'ts': [959722930, 961493271, 966717146, 971437573]},
 'NEW RESOLVED': {'num': 1506, 'ts': [965705416, 1021116874]},
 'NEW RESOLVED VERIFIED': {'num': 10563,
  'ts': [960227506, 964279287, 968902410]},
 'UNCONFIRMED NEW ASSIGNED RESOLVED VERIFIED': {'num': 960,
  'ts': [963460778, 964149963, 967345129, 973755474, 980765219]},
 'UNCONFIRMED NEW RESOLVED VERIFIED': {'num': 2279,
  'ts': [964684927, 965322058, 971773362, 978675395]},
 'UNCONFIRMED RESOLVED VERIFIED': {'num': 6065,
  'ts': [963700915, 964321820, 968707193]}};
	
function parseTree(d){
	//caculate the time gap
	for (tranStr in d)
	{
		initST = d[tranStr]["ts"][0];
		d[tranStr]["ts"][0] = 0;
		for (i = 1; i < d[tranStr]["ts"].length; i++)
		{
			d[tranStr]["ts"][i] -= initST + d[tranStr]["ts"][i-1];
		}
	}

	//build a tree
	var nodeId = 0;
	var rr = {"child":{},"tag":"root",id:nodeId++};
	var mergeThres = 0.2;
	for (tranStr in d){
		tranArr = tranStr.split(" ");
		curNode = rr;
		tranAttr = d[tranStr];
		endInd = tranArr.length - 1;
		//iterate through a transition str
		for (i in tranArr){
			curTran = tranArr[i];
			// check whether to merge the node
			// find a node to merge
			ind = 0;
			tranStr = curTran;
			curTran = curTran + ind;
			if (i > 0) {
				while(curTran in curNode["child"]) {
					oldGap = curNode["child"][curTran]["ts"];
					newGap = tranAttr["ts"][i];
					gapDiff = Math.abs(oldGap-newGap);
					// if the gap difference is small, merge
					if(gapDiff <= oldGap * mergeThres){
						break;
					}
					else{
						ind++;
						curTran = tranStr + ind;
					}
				}
			}
			// merge or not
			if(curTran in curNode["child"]){
				curNode = curNode["child"][curTran];
				// average the ts
				totalNum = curNode["num"] + tranAttr["num"]
				curNode["ts"] = parseInt((curNode["num"] * curNode["ts"] + tranAttr["num"] * tranAttr["ts"][i]) / totalNum);
				curNode["num"] = totalNum;
			}
			else{		// a new node
				curNode["child"][curTran]={"child":{},"tag":tranStr,"id":nodeId++};
				curNode = curNode["child"][curTran];
				curNode["num"] = tranAttr["num"];
				curNode["ts"] = tranAttr["ts"][i];
			}
			// if it is an end, add a node
			if(i == endInd){
				curNode["child"]["END"] = {"num":tranAttr["num"],"ts":tranAttr["ts"][i]};
			}
		}
	}
	return rr;
}

svgWidth = parseInt($("#svg-wrap").css("width")) - parseInt($("#svg-wrap").css("padding-left")) - parseInt($("#svg-wrap").css("padding-right"));
svgHeight = parseInt($("#svg-wrap").css("height")) - parseInt($("#svg-wrap").css("padding-bottom")) - parseInt($("#svg-wrap").css("padding-top"));
svgAttr = {"width":svgWidth,"height":svgHeight,"paddingV":20,"paddingH":10};

var colors = {"canvas":"#FFFFFF","node":"#EEEEE0","text":"#000000","edge":"#36648B","nodeBorder":"#EEE0E0"}

var svg = d3.select("#svg-wrap")     //选择文档中的body元素
    .append("svg")          //添加一个svg元素
    .attr("width", svgAttr.width)       //设定宽度
    .attr("height", svgAttr.height);
	//.style("background-color",colors.canvas);    //设定高度

r = parseTree(d);
  
// calculate the depth of the tree
function findDepth(d){	
	maxDepth = 0;
	for (tranStr in d){
		tranArr = tranStr.split(" ");
		depth = tranArr.length;
		if(depth > maxDepth){
			maxDepth = depth;
		}
	}
	return maxDepth;
}

treeDepth = findDepth(d);

// calculate the depth of the tree
function findTotalTS(d){	
	return maxTotalTS;
}

var maxTotalTS = findTotalTS(d);



function searchWidth(node){
	hasChild = false;
	for(childStr in node["child"]){
		if (childStr != "END"){
			hasChild = true;
			break;
		}
	}
	if(!hasChild){
		node["maxWidth"] = 1;
		return 1;
	}
	maxWidth = 0;
	for(childStr in node["child"]){
		if (childStr != "END"){
			maxWidth += searchWidth(node["child"][childStr],depth+1);
		}
	}
	node["maxWidth"] = maxWidth;
	return maxWidth;
}

searchWidth(r);


function buildScale(svgAttr,r,d,tDepth){
		
	// a series of rate
	var innerGapRate = 0.5;
	var widthLineNodeRate = 0.5
	var minLineWidth = 4;
	var maxLineWidth = 10;
	
	maxR = (svgAttr.width - svgAttr.paddingH * 2) / ((innerGapRate + 2) * r.maxWidth - innerGapRate);
	minR = maxR * 0.6;	
	
	//build the scale of the radius
	maxNum = 0;
	minNum = 9999999;	//this is a assumed biggest number
	for (tranStr in d){
		maxNum = Math.max(maxNum,d[tranStr].num);
		minNum = Math.min(minNum,d[tranStr].num);
	}
	crScale = d3.scale.linear()
		.domain([minNum, maxNum])
        .range([minR, maxR]);
	
	// scale of the width of edge in the tree
	maxLineWidth = Math.min(maxR * widthLineNodeRate,maxLineWidth);
	edgeWidthScale = d3.scale.linear()
		.domain([minNum, maxNum])
        .range([minLineWidth, maxLineWidth]);
	
	// scale of the length of edge in the tree
	var maxTotalTS = 0;
	for (tranStr in d){
		var curTotal = 0;
		for(i in d[tranStr].ts){
			curTotal += d[tranStr].ts[i] 
		}
		if(curTotal > maxTotalTS){
			maxTotalTS = curTotal;
		}
	}
	tsScale = d3.scale.linear()
		.domain([0, maxTotalTS])
        .range([0, svgAttr.height - svgAttr.paddingV * 2 - tDepth * minR * 2]);
	
	treeScale = {"crScale":crScale,"tsScale":tsScale,"edgeWidthScale":edgeWidthScale};
	return treeScale;
}

treeScale = buildScale(svgAttr,r,d,treeDepth);


function drawNode(node,cx,cy,cr){
	svg.append("circle").attr("cx",cx)
						.attr("cy",cy)
						.attr("r",cr)
						.attr("class","mycir")
						.attr("fill",colors.node)
						.attr("stroke",colors.nodeBorder)
						.attr("stroke-opacity",0.8)
						.attr("stroke-width",5);
						
	svg.append("text").attr("x",cx)
						.attr("y",cy)
						.attr("text-anchor","middle")
						.attr("fill",colors.text)
						.text(node.tag);
}
function drawEdge(lEdgeX,lEdgeY,node,cx,cy,cr){
	var edgeWidth = treeScale.edgeWidthScale(node.num);
	//draw the edge
	if(lEdgeX != 0 && lEdgeY != 0){
		if(Math.abs(lEdgeX - cx) < 1){
			svg.append("line").attr("x1",lEdgeX)
						.attr("y1",lEdgeY)
						.attr("x2",cx)
						.attr("y2",cy - cr)
						.style("stroke",colors.edge)
						.style("stroke-width",edgeWidth);			
		}
		else{
			var curRate = 0.4;
			var distY = cy - cr - lEdgeY;
			var turningY = lEdgeY + distY * curRate;
			var dParam = "M "+ lEdgeX + "," + (lEdgeY - edgeWidth * 0.5) + " Q " + cx + "," + lEdgeY + " " + cx + ","+ turningY;
			svg.append("path").attr("d",dParam)
							.attr("fill","none")
							.style("stroke",colors.edge)
							.style("stroke-width",edgeWidth);
			svg.append("line").attr("x1",cx)
							.attr("y1",turningY)
							.attr("x2",cx)
							.attr("y2",cy - cr)
							.style("stroke",colors.edge)
							.style("stroke-width",edgeWidth);	
		}
	}
}

function drawTree(lEdgeX,lEdgeY,node,left,right,lastEdge){
		
	var cx,cy,cr;
	if(node.tag != 'root'){
		var thisEdge = lastEdge + treeScale.tsScale(node.ts) + treeScale.crScale(node.num) * 2;
		cx = (left + right) / 2;
		cy = thisEdge - treeScale.crScale(node.num);
		cr = treeScale.crScale(node.num);
	}
	else{
		var thisEdge = lastEdge;
		cx = cy = -1;
	}
	
	//draw the edge
	drawEdge(lEdgeX,lEdgeY,node,cx,cy,cr);

	//sort the child, draw the biggest first
	var totalChildNum = 0;
	function tranSort(a,b){
		return b.num - a.num;
	}
	// both sort and find the min ts among the children
	var tranSortArr = new Array();
	var minTS = 9999999;
	var endNum = 0;
	for(var childStr in node.child){
		if(childStr != 'END'){
			tranSortArr.push({"name":childStr,"num":node.child[childStr].num});
			totalChildNum += node.child[childStr].num;
			minTS = Math.min(node.child[childStr].ts,minTS);
		}
		else{
			endNum = node.child[childStr].num;
		}
	}
	var edgeX = 0;
	var edgeY = 0;
	// draw a part of the edge
	if (totalChildNum != 0 && node.tag != "root"){
		edgeX = cx;
		edgeY = cy + cr + treeScale.tsScale(minTS) * 0.2;
		svg.append("line").attr("x1",edgeX)
						.attr("y1",cy + cr)
						.attr("x2",edgeX)
						.attr("y2",edgeY)
						.style("stroke",colors.edge)
						.style("stroke-width",treeScale.edgeWidthScale(node.num - endNum));
	}
	tranSortArr.sort(tranSort);
	
	//iterate through the children
	var curLeft = left;
	var curDist = right-left;
	for(var ind in tranSortArr){
		childStr = tranSortArr[ind].name;
		var distRate = ((node.child[childStr].maxWidth / node.maxWidth) + (node.child[childStr].num / totalChildNum)) / 2;
		var dist = curDist * distRate;
		//draw the tree of son
		drawTree(edgeX,edgeY,node.child[childStr],curLeft,curLeft+dist,thisEdge);
		curLeft = curLeft+dist;
	}
	// draw the node
	if(node.tag != 'root'){
		drawNode(node,cx,cy,cr);
	}
}
drawTree(0,0,r,svgAttr.paddingH,svgAttr.width - svgAttr.paddingH,svgAttr.paddingV);

var axis = d3.svg.axis()
     .scale(treeScale.tsScale)      //指定比例尺
     .orient("left")   //指定刻度的方向
     .ticks(7);          //指定刻度的数量

svg.append("g")
	.attr("class","axis")
	.attr("transform","translate(" + svgAttr.paddingH * 2 + "," + svgAttr.paddingV + ")")
	.call(axis);

console.log(r);



</script>
</body>
</html>